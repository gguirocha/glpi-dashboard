-- 1. PROFILES Table
create table if not exists profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  role text default 'user' check (role in ('user', 'admin')),
  email text
);

-- RLS for Profiles
alter table profiles enable row level security;

do $$
begin
  if not exists (select 1 from pg_policies where policyname = 'Public profiles are viewable by everyone.' and tablename = 'profiles') then
    create policy "Public profiles are viewable by everyone." on profiles for select using ( true );
  end if;

  if not exists (select 1 from pg_policies where policyname = 'Users can insert their own profile.' and tablename = 'profiles') then
    create policy "Users can insert their own profile." on profiles for insert with check ( auth.uid() = id );
  end if;

  if not exists (select 1 from pg_policies where policyname = 'Users can update own profile.' and tablename = 'profiles') then
    create policy "Users can update own profile." on profiles for update using ( auth.uid() = id );
  end if;
end $$;

-- 2. DASHBOARD TICKETS Table
create table if not exists dashboard_tickets (
    id bigint primary key,
    name text,
    status_id integer,
    date_creation timestamp with time zone,
    date_solved timestamp with time zone,
    date_closed timestamp with time zone,
    time_to_resolve integer,
    time_to_resolve_min integer,
    locations_name text,
    itilcategories_name text,
    users_name_assign text,
    priority integer,
    urgency integer,
    impact integer,
    slas_name text,
    sla_time_limit timestamp with time zone,
    sla_waiting_duration integer default 0,
    groups_name_tech text,
    projects_id integer default 0
);

-- RLS for Tickets (Viewable by authenticated users)
alter table dashboard_tickets enable row level security;

do $$
begin
  if not exists (select 1 from pg_policies where policyname = 'Enable read access for all users' and tablename = 'dashboard_tickets') then
    create policy "Enable read access for all users" on dashboard_tickets for select using ( true );
  end if;
    
  if not exists (select 1 from pg_policies where policyname = 'Enable insert for service key' and tablename = 'dashboard_tickets') then
      create policy "Enable insert for service key" on dashboard_tickets for insert with check ( true ); 
  end if;

   if not exists (select 1 from pg_policies where policyname = 'Enable update for service key' and tablename = 'dashboard_tickets') then
      create policy "Enable update for service key" on dashboard_tickets for update using ( true ); 
  end if;
  
  if not exists (select 1 from pg_policies where policyname = 'Enable delete for service key' and tablename = 'dashboard_tickets') then
      create policy "Enable delete for service key" on dashboard_tickets for delete using ( true ); 
  end if;
end $$;


-- 3. PROJECTS Table
create table if not exists projects (
    id bigint generated by default as identity primary key,
    name text not null,
    glpi_project_id integer,
    description text,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    status text,
    percent_done integer,
    department text
);

alter table projects enable row level security;
do $$
begin
  if not exists (select 1 from pg_policies where policyname = 'Enable read access for all users' and tablename = 'projects') then
    create policy "Enable read access for all users" on projects for select using ( true );
  end if;
end $$;

-- 4. TRIGGERS & FUNCTIONS
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, username, role, email)
  values (
    new.id, 
    new.raw_user_meta_data->>'full_name', 
    new.raw_user_meta_data->>'username', 
    coalesce(new.raw_user_meta_data->>'role', 'user'),
    new.email
  )
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname = 'on_auth_user_created') then
    create trigger on_auth_user_created
      after insert on auth.users
      for each row execute procedure public.handle_new_user();
  end if;
end $$;
